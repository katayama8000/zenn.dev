---
title: 'Rustã¨DDDã§APIã‚µãƒ¼ãƒãƒ¼ã‚’æ§‹ç¯‰ã™ã‚‹'
emoji: 'ğŸ¦'
type: 'tech' # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: [Rust, axum, ddd, api]
published: true
published_at: 2024-02-29 12:30
publication_name: 'doctormate'
---

## ã¯ã˜ã‚ã«

Rust ã¨ ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ axum ã‚’ä½¿ã£ã¦ã€API ã‚µãƒ¼ãƒãƒ¼ã‚’å®Ÿè£…ã—ã¦ã¿ã¾ã—ãŸã€‚

### å¯¾è±¡èª­è€…

- Rust ã§ API ã‚µãƒ¼ãƒãƒ¼ã‚’å®Ÿè£…ã—ãŸã„äºº
- Rust ã§ DDD ã‚’å®Ÿè£…ã—ãŸã„äºº

### èª¬æ˜ã—ãªã„ã“ã¨

- Rust ã®åŸºæœ¬çš„ãªæ–‡æ³•
- DDD ã®åŸºæœ¬çš„ãªè€ƒãˆæ–¹
- ä½¿ç”¨ã‚¯ãƒ¬ãƒ¼ãƒˆã®ä½¿ã„æ–¹

## ä¾å­˜ã®æ–¹å‘

![ä¾å­˜é–¢ä¿‚](/images/rust-ddd/dependency-ddd.png)
ä»Šå›ã®ä½œæˆã™ã‚‹ã€ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã®ä¾å­˜é–¢ä¿‚ã¯ã€ä¸Šè¨˜ã®ã‚ˆã†ã«ãªã‚Šã¾ã™ã€‚
ä¸Šè¨˜ã®ä¾å­˜é–¢ä¿‚ã‚’é ­ã®ç‰‡éš…ã«ç½®ã„ã¦ã€è¨˜äº‹ã‚’èª­ã¿é€²ã‚ã¦ã„ãŸã ã‘ã‚‹ã¨ã€ç†è§£ãŒæ·±ã¾ã‚‹ã¨æ€ã„ã¾ã™ã€‚
ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ä¾å­˜ã—ãªã„ã“ã¨ãŒé‡è¦ã§ã™ã€‚

## ã„ã–ã€å®Ÿè£…

### ä»•æ§˜ã‚’æ±ºã‚ã‚‹

ä»Šå›ã¯ã€å¤§å­¦ãŒã€ã‚µãƒ¼ã‚¯ãƒ«ã‚’ç®¡ç†ã™ã‚‹ã‚·ã‚¹ãƒ†ãƒ ã‚’ä½œã‚‹ã“ã¨ã«ã—ã¾ã—ãŸã€‚

- ãƒ¡ãƒ³ãƒãƒ¼ã‚’è¿½åŠ ã§ãã‚‹
  - 4 å¹´ç”Ÿã¯ã€è¿½åŠ ã§ããªã„
- ãƒ¡ãƒ³ãƒãƒ¼ã‚’å‰Šé™¤ã§ãã‚‹
  - ã‚ªãƒ¼ãƒŠãƒ¼ã¯å‰Šé™¤ã§ããªã„
- 4 å¹´ç”Ÿã¯ã€å’æ¥­ã™ã‚‹
- ã‚µãƒ¼ã‚¯ãƒ«ã¯æœ€ä½ 3 äººä»¥ä¸Šã§ãªã„ã¨ã€æ´»å‹•ã§ããªã„
- ã‚µãƒ¼ã‚¯ãƒ«ã¯ã€æœ€å¤§äººæ•°ãŒæ±ºã¾ã£ã¦ã„ã‚‹
- ã‚µãƒ¼ã‚¯ãƒ«ã«ã¯ã€ä»£è¡¨è€…ãŒå¿…è¦
- 20 æ­³ä»¥ä¸Šã®äººã¯ã€é£²ã¿ä¼šã«å‚åŠ ã§ãã‚‹
- 3 å¹´ç”Ÿã®ã¿ã€ã‚µãƒ¼ã‚¯ãƒ«ã®ä»£è¡¨è€…ã«ãªã‚Œã‚‹

### ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ¬ã‚¤ãƒ¤ãƒ¼

#### ã‚µãƒ¼ã‚¯ãƒ«é›†ç´„

ã¾ãšã¯ã€ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã‚‰ä½œæˆã—ã¾ã™ã€‚
ã‚µãƒ¼ã‚¯ãƒ«é›†ç´„ã¯ã€é›†ç´„ãƒ«ãƒ¼ãƒˆã«ãªã‚‹ `Circle` ã¨ã€é›†ç´„å†…ã®ãƒ¡ãƒ³ãƒãƒ¼ã‚’è¡¨ã™ `Member` ã® 2 ã¤ã®ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‹ã‚‰æ§‹æˆã•ã‚Œã¾ã™ã€‚

```Rust
pub struct Circle {
    pub id: CircleId, // ã‚µãƒ¼ã‚¯ãƒ«ã®ID (Value Object)
    pub name: String,
    pub capacity: usize,
    pub owner: Member,
    pub members: Vec<Member>,
}
```

```Rust
pub struct Member {
    pub id: MemberId, // ãƒ¡ãƒ³ãƒãƒ¼ã®ID (Value Object)
    pub name: String,
    pub age: usize,
    pub grade: Grade,
    pub major: Major,
}
```

id ã«ã¯ `Value Object` ã‚’ä½¿ã£ã¦ã„ã¾ã™ã€‚ä»Šå›ã€`Entity` ã¨ `Value Object` ã®é•ã„ãªã©ã¯ã€èª¬æ˜ã—ã¾ã›ã‚“ã®ã§ã€èˆˆå‘³ãŒã‚ã‚‹æ–¹ã¯ã€èª¿ã¹ã¦ã¿ã¦ãã ã•ã„ã€‚

:::details CircleId

```Rust
use std::fmt;
use std::hash::{Hash, Hasher};

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct CircleId(usize);

impl CircleId {
    pub fn gen() -> Self {
        Self(rand::random::<usize>())
    }
}

impl std::convert::From<usize> for CircleId {
    fn from(id: usize) -> Self {
        Self(id)
    }
}

impl Hash for CircleId {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.0.hash(state);
    }
}

impl fmt::Display for CircleId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl std::convert::From<CircleId> for usize {
    fn from(circle_id: CircleId) -> usize {
        circle_id.0
    }
}
```

:::

æ¬¡ã«ã€é›†ç´„ã«çŸ¥è­˜ã‚’ã‚ãŸãˆã‚‹ãŸã‚ã«ã€ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¾ã™ã€‚
Rust ã§ã¯ `impl` ã§ `struct` ã«ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¾ã™ã€‚

```Rust
use crate::domain::aggregate::member::Member;
use crate::domain::aggregate::value_object::circle_id::CircleId;

use super::value_object::grade::Grade;
use anyhow::Error;

#[derive(Clone, Debug, Eq, PartialEq)]
pub struct Circle {
    pub id: CircleId, // ã‚µãƒ¼ã‚¯ãƒ«ã®ID (Value Object)
    pub name: String,
    pub capacity: usize,
    pub owner: Member,
    pub members: Vec<Member>,
}

impl Circle {
    // ã‚µãƒ¼ã‚¯ãƒ«ã®æ–°è¦ä½œæˆãƒ¡ã‚½ãƒƒãƒ‰
    pub fn new(name: String, owner: Member, capacity: usize) -> Result<Self, Error> {
        // ã‚ªãƒ¼ãƒŠãƒ¼ã¯3å¹´ç”Ÿã®ã¿ãªã‚Œã‚‹
        if owner.grade != Grade::Third {
            return Err(Error::msg("Owner must be 3rd grade"));
        }

        // ã‚µãƒ¼ã‚¯ãƒ«ã®å®šå“¡ã¯3äººä»¥ä¸Š
        if capacity < 3 {
            return Err(Error::msg("Circle capacity must be 3 or more"));
        }

        Ok(Circle {
            id: CircleId::gen(),
            name,
            owner,
            capacity,
            members: vec![],
        })
    }

    // ã‚µãƒ¼ã‚¯ãƒ«ã®å†æ§‹æˆãƒ¡ã‚½ãƒƒãƒ‰
    pub fn reconstruct(
        id: CircleId,
        name: String,
        owner: Member,
        capacity: usize,
        members: Vec<Member>,
    ) -> Self {
        Circle {
            id,
            name,
            owner,
            capacity,
            members,
        }
    }

    // ã‚µãƒ¼ã‚¯ãƒ«ã®æ›´æ–°ãƒ¡ã‚½ãƒƒãƒ‰
    pub fn update(&mut self, name: Option<String>, capacity: Option<usize>) {
        if let Some(name) = name {
            self.name = name;
        }
        if let Some(capacity) = capacity {
            self.capacity = capacity;
        };
    }

    // ã‚µãƒ¼ã‚¯ãƒ«ãŒæº€å“¡ã‹ã©ã†ã‹ã‚’åˆ¤å®šã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰
    fn is_full(&self) -> bool {
        self.members.len() + 1 >= self.capacity
    }

    // ã‚µãƒ¼ã‚¯ãƒ«ãŒé‹å–¶å¯èƒ½ã‹ã©ã†ã‹ã‚’åˆ¤å®šã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰
    fn is_runnable(&self) -> bool {
        self.members.len() + 1 >= 3
    }

    // é£²ã¿ä¼šã«å‚åŠ ã§ãã‚‹ã‹ã©ã†ã‹ã‚’åˆ¤å®šã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰
    fn is_drinkable_alcohol(member: &Member) -> bool {
        member.is_adult()
    }

    // ãƒ¡ãƒ³ãƒãƒ¼ã‚’ã‚µãƒ¼ã‚¯ãƒ«ã«è¿½åŠ ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰
    pub fn add_member(&mut self, member: Member) -> Result<(), Error> {
        // æº€å“¡ã®å ´åˆã¯ã‚µãƒ¼ã‚¯ãƒ«ã«å…¥ã‚Œãªã„
        if self.is_full() {
            return Err(Error::msg("Circle member is full"));
        }

        // 4å¹´ç”Ÿã¯ã‚µãƒ¼ã‚¯ãƒ«ã«å…¥ã‚Œãªã„
        if member.grade == Grade::Fourth {
            return Err(Error::msg("4th grade can't join circle"));
        }

        self.members.push(member);
        Ok(())
    }

    // ãƒ¡ãƒ³ãƒãƒ¼ã‚’ã‚µãƒ¼ã‚¯ãƒ«ã‹ã‚‰å‰Šé™¤ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰
    pub fn remove_member(&mut self, member: &Member) -> Result<(), Error> {
        // ã‚ªãƒ¼ãƒŠãƒ¼ã¯å‰Šé™¤ã§ããªã„
        if self.owner.id == member.id {
            return Err(Error::msg("Owner can't be removed"));
        }
        self.members.retain(|m| m.id != member.id);
        Ok(())
    }

    // 4å¹´ç”Ÿã‚’å’æ¥­ã•ã›ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰
    pub fn graduate(&mut self) {
        self.members.retain(|m| m.grade != Grade::Fourth);
    }
}
```

```Rust
impl Member {
    // ãƒ¡ãƒ³ãƒãƒ¼ã®æ–°è¦ä½œæˆãƒ¡ã‚½ãƒƒãƒ‰
    pub fn new(name: String, age: usize, grade: Grade, major: Major) -> Self {
        Member {
            id: MemberId::gen(),
            name,
            age,
            grade,
            major,
        }
    }

    // ãƒ¡ãƒ³ãƒãƒ¼ã®å†æ§‹æˆãƒ¡ã‚½ãƒƒãƒ‰
    pub fn reconstruct(id: MemberId, name: String, age: usize, grade: Grade, major: Major) -> Self {
        Member {
            id,
            name,
            age,
            grade,
            major,
        }
    }

    // 20æ­³ä»¥ä¸Šã‹ã©ã†ã‹ã‚’åˆ¤å®šã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰
    pub fn is_adult(&self) -> bool {
        self.age >= 20
    }
}
```

#### ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

ãƒ‰ãƒ¡ã‚¤ãƒ³ã®æŒ¯ã‚‹èˆã„ã‚’å¤–éƒ¨ã«å…¬é–‹ã™ã‚‹ãŸã‚ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’ä½œæˆã—ã¾ã™ã€‚
ã‚µãƒ¼ã‚¯ãƒ«é›†ç´„ã‚’æ“ä½œã™ã‚‹ãŸã‚ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’ä½œæˆã—ã¾ã™ã€‚

```Rust
pub trait CircleRepositoryInterface {
    fn find_circle_by_id(&self, circle_id: &CircleId) -> Result<Circle, Error>;
    fn create(&self, circle: &Circle) -> Result<(), Error>;
    fn update(&self, circle: &Circle) -> Result<Circle, Error>;
    fn delete(&self, circle: &Circle) -> Result<(), Error>;
}
```

`trait`ã¯ã€ä»–ã®è¨€èªã§è¨€ã†ã¨ã“ã‚ã®`interface`ã®ã‚ˆã†ãªã‚‚ã®ã§ã™ã€‚

### ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£ãƒ¬ã‚¤ãƒ¤ãƒ¼

ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ã€æ°¸ç¶šåŒ–ã‚’æ‹…ã„ã¾ã™ã€‚
æ°¸ç¶šåŒ–å…ˆã¯å•ã„ã¾ã›ã‚“ã€‚`Firestore` ã‚„ `Postgres` ãªã©ã€ãªã‚“ã§ã‚‚è‰¯ã„ã§ã™ã€‚
ä»Šå›ã¯ã€ãƒ¡ãƒ¢ãƒªã«ä¿å­˜ã™ã‚‹ã“ã¨ã«ã—ã¾ã—ãŸã€‚

ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£ãƒ¬ã‚¤ãƒ¤ãƒ¼ã§ã¯ã€ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã‚’å®Ÿè£…ã—ã¾ã™ã€‚

```Rust
use anyhow::Error;

use crate::domain::{
    aggregate::{
        circle::Circle,
        member::Member,
        value_object::{circle_id::CircleId, grade::Grade, major::Major, member_id::MemberId},
    },
    interface::circle_repository_interface::CircleRepositoryInterface,
};

use super::db::Db;

#[derive(Clone, Debug)]
pub struct CircleRepository {
    db: Db,
}

impl CircleRepository {
    pub fn new() -> Self {
        Self { db: Db::new() }
    }
}

impl CircleRepositoryInterface for CircleRepository {
    fn find_circle_by_id(&self, circle_id: &CircleId) -> Result<Circle, Error> {
        match self.db.get::<CircleData, _>(&circle_id.to_string())? {
            Some(data) => Ok(Circle::try_from(data)?),
            None => Err(Error::msg("Circle not found")),
        }
    }

    fn create(&self, circle: &Circle) -> Result<(), Error> {
        match self.db.get::<CircleData, _>(&circle.id.to_string())? {
            Some(_) => Err(Error::msg("Circle already exists")),
            None => {
                self.db
                    .set(circle.id.to_string(), &CircleData::from(circle.clone()))?;
                Ok(())
            }
        }
    }

    fn update(&self, circle: &Circle) -> Result<Circle, Error> {
        match self.db.get::<CircleData, _>(&circle.id.to_string())? {
            Some(_) => self
                .db
                .set(circle.id.to_string(), &CircleData::from(circle.clone()))
                .and_then(|_| self.db.get::<CircleData, _>(&circle.id.to_string()))
                .map(|data| match data {
                    Some(data) => Circle::try_from(data),
                    None => Err(Error::msg("Failed to convert circle data")),
                })?,
            None => Err(Error::msg("Circle not found")),
        }
    }

    fn delete(&self, circle: &Circle) -> Result<(), Error> {
        match self.db.get::<CircleData, _>(&circle.id.to_string())? {
            Some(_) => self.db.remove(circle.id.to_string()),
            None => Err(Error::msg("Circle not found")),
        }
    }
}

#[derive(serde::Deserialize, serde::Serialize)]
struct CircleData {
    id: usize,
    name: String,
    owner: MemberData,
    capacity: usize,
    members: Vec<MemberData>,
}

impl std::convert::From<Circle> for CircleData {
    fn from(circle: Circle) -> Self {
        CircleData {
            id: circle.id.into(),
            name: circle.name,
            owner: MemberData::from(circle.owner),
            capacity: circle.capacity,
            members: circle.members.into_iter().map(MemberData::from).collect(),
        }
    }
}

impl std::convert::TryFrom<CircleData> for Circle {
    type Error = Error;

    fn try_from(data: CircleData) -> Result<Self, Self::Error> {
        Ok(Circle::reconstruct(
            CircleId::from(data.id),
            data.name,
            Member::reconstruct(
                MemberId::from(data.owner.id),
                data.owner.name,
                data.owner.age,
                Grade::try_from(data.owner.grade)?,
                Major::from(data.owner.major.as_str()),
            ),
            data.capacity,
            data.members
                .into_iter()
                .map(Member::try_from)
                .collect::<Result<Vec<Member>, Error>>()?,
        ))
    }
}

#[derive(serde::Deserialize, serde::Serialize)]
struct MemberData {
    id: usize,
    name: String,
    age: usize,
    grade: usize,
    major: String,
}

impl std::convert::From<Member> for MemberData {
    fn from(value: Member) -> Self {
        Self {
            id: value.id.into(),
            name: value.name,
            age: value.age,
            grade: value.grade.into(),
            major: value.major.into(),
        }
    }
}

impl std::convert::TryFrom<MemberData> for Member {
    type Error = Error;

    fn try_from(value: MemberData) -> Result<Self, Self::Error> {
        Ok(Member::reconstruct(
            MemberId::from(value.id),
            value.name,
            value.age,
            Grade::try_from(value.grade)?,
            Major::from(value.major.as_str()),
        ))
    }
}
```

ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‹ã‚‰å–å¾—ã—ãŸå€¤ã‚’ã€`XxxData`ã¨ã„ã†åå‰ã§è¡¨ã—ã¦ã„ã¾ã™ã€‚ä»Šå›ã¯ã€`CircleData` ã¨ `MemberData` ã§ã™ã€‚
ã“ã®ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®å‹ã‚’ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‹ã«å¤‰æ›ã™ã‚‹ãŸã‚ã«ã€`TryFrom` ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã—ã€å†…éƒ¨ã§ã€`reconstruct` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ã£ã¦ã€ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®`Entity`ã®å‹ã«å¤‰æ›ã—ã¦ã„ã¾ã™ã€‚
ä»Šå›ã¯ DB ãŒ ã‚ªãƒ³ãƒ¡ãƒ¢ãƒªãªã®ã§ã€ã‚ã¾ã‚Šæ„å‘³ã‚’æ„Ÿã˜ã«ãã„ã§ã™ãŒã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å±¤ã¨ã®ä¾å­˜ã‚’ãªãã™ã®ã«æœ‰åŠ¹ã§ã™ã€‚
DB ãŒçªç„¶ã€`Firebase` ã«å¤‰ã‚ã£ã¦ã‚‚ã€ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®å‹ã‚’å¤‰ãˆã‚‹ã ã‘ã§ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å±¤ã«ã¯å½±éŸ¿ã‚’ä¸ãˆã¾ã›ã‚“ã€‚
ãã®ãŸã‚ã«ã‚‚ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å±¤ãŒã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ä¾å­˜ã—ãªã„ã‚ˆã†ã«æŠ½è±¡ã«ä¾å­˜ã•ã›ã‚‹ã“ã¨ãŒé‡è¦ã§ã™ã€‚(å¾Œè¿°ã—ã¾ã™)

DB ã®å®Ÿè£…ã¯ DDD ã«ãã‚Œã»ã©é–¢ä¿‚ãªã„ã®ã§ã€èˆˆå‘³ã®ã‚ã‚‹æ–¹ã¯è¦‹ã¦ãã ã•ã„ã€‚
:::details ãƒ¡ãƒ¢ãƒªä¸Šã«ä¿å­˜ã™ã‚‹ DB ã®å®Ÿè£…

```Rust
use std::{
    collections::HashMap,
    sync::{Arc, RwLock},
};

#[derive(Clone, Debug)]
pub struct Db {
    db: Arc<RwLock<HashMap<String, String>>>,
}

impl Db {
    pub fn new() -> Self {
        Self {
            db: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    pub fn get<D, K>(&self, key: K) -> anyhow::Result<Option<D>>
    where
        K: AsRef<str>,
        D: serde::de::DeserializeOwned,
    {
        let db = self
            .db
            .read()
            .map_err(|e| anyhow::anyhow!("Error reading from database: {:?}", e))?;

        match db.get(key.as_ref()) {
            Some(value) => {
                let deserialized_value = serde_json::from_str(value)
                    .map_err(|e| anyhow::anyhow!("Error deserializing value: {:?}", e))?;
                Ok(Some(deserialized_value))
            }
            None => Ok(None),
        }
    }

    pub fn keys(&self) -> Vec<String> {
        let db = self.db.read().expect("read data from db");
        db.keys().cloned().collect()
    }

    pub fn remove<K>(&self, key: K) -> anyhow::Result<()>
    where
        K: AsRef<str>,
    {
        let mut db = self
            .db
            .write()
            .map_err(|e| anyhow::anyhow!("Error writing to database: {:?}", e))?;
        db.remove(key.as_ref())
            .ok_or_else(|| anyhow::anyhow!("Key not found in database"))?;
        Ok(())
    }

    pub fn set<S, K>(&self, key: K, value: &S) -> anyhow::Result<()>
    where
        K: Into<String>,
        S: serde::ser::Serialize,
    {
        let value = serde_json::to_string(value)?;
        let mut db = self
            .db
            .write()
            .map_err(|e| anyhow::anyhow!("Error writing to database: {:?}", e))?;
        db.insert(key.into(), value);
        Ok(())
    }
}
```

RawLock ã‚’ä½¿ã£ã¦ã€æ’ä»–åˆ¶å¾¡ã‚’ã—ã¦ã„ã¾ã™ã€‚
:::

### ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¬ã‚¤ãƒ¤ãƒ¼

ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¬ã‚¤ãƒ¤ãƒ¼ã§ã¯ã€ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ã®å®Ÿç¾ã®ãŸã‚ã«ã€`Entity` ã‚„ `VO` ã‚’ä½¿ã£ã¦ã€ãƒ¬ãƒã‚¸ãƒˆãƒªãƒ¼ (ã‚¤ãƒ³ãƒ•ãƒ©å±¤) ã«å‡¦ç†ã‚’ä¾é ¼ã—ã¾ã™ã€‚
ãƒ¬ãƒã‚¸ãƒˆãƒªãƒ¼ã«å‡¦ç†ã‚’ä¾é ¼ã—ã¾ã™ãŒã€ã‚¤ãƒ³ãƒ•ãƒ©å±¤ã«ã¯ä¾å­˜ã—ã¾ã›ã‚“ã€‚
ã„ã‚ã‚†ã‚‹ã€ä¾å­˜æ€§é€†è»¢ã®åŸå‰‡ã‚’ç”¨ã„ã¦ã€ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ã‚’å®Ÿç¾ã—ã¾ã™ã€‚
å®Ÿæ…‹ã§ã¯ãªãã€æŠ½è±¡ã«ä¾å­˜ã•ã›ã‚‹ãŸã‚ã«ã€ãƒˆãƒ¬ã‚¤ãƒˆã‚’ä½¿ã„ã¾ã™ã€‚
ä»Šå›ã¯ã€ã‚µãƒ¼ã‚¯ãƒ«ã‚’ä½œæˆã™ã‚‹ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ã‚’å®Ÿè£…ã—ã¾ã™ã€‚

```Rust
use anyhow::Result;
use serde::Deserialize;

use crate::domain::{
    aggregate::{
        circle::Circle,
        member::Member,
        value_object::{grade::Grade, major::Major},
    },
    interface::circle_repository_interface::CircleRepositoryInterface,
};

#[derive(Debug, Deserialize)]
pub struct CreateCircleInput {
    pub circle_name: String,
    pub capacity: usize,
    pub owner_name: String,
    pub owner_age: usize,
    pub owner_grade: usize,
    pub owner_major: String,
}

impl CreateCircleInput {
    pub fn new(
        circle_name: String,
        capacity: usize,
        owner_name: String,
        owner_age: usize,
        owner_grade: usize,
        owner_major: String,
    ) -> Self {
        CreateCircleInput {
            circle_name,
            capacity,
            owner_name,
            owner_age,
            owner_grade,
            owner_major,
        }
    }
}

#[derive(Debug, Deserialize)]
pub struct CreateCircleOutput {
    pub circle_id: usize,
    pub owner_id: usize,
}

pub struct CreateCircleUsecase<T>
where
    T: CircleRepositoryInterface,
{
    circle_repository: T,
}

impl<T> CreateCircleUsecase<T>
where
    T: CircleRepositoryInterface,
{
    pub fn new(circle_repository: T) -> Self {
        CreateCircleUsecase { circle_repository }
    }

    pub fn execute(
        &mut self,
        circle_circle_input: CreateCircleInput,
    ) -> Result<CreateCircleOutput> {
        let grade = Grade::try_from(circle_circle_input.owner_grade)?;

        let major = Major::from(circle_circle_input.owner_major.as_str());

        let owner = Member::new(
            circle_circle_input.owner_name,
            circle_circle_input.owner_age,
            grade,
            major,
        );
        let owner_id = owner.id;
        let circle = Circle::new(
            circle_circle_input.circle_name,
            owner,
            circle_circle_input.capacity,
        )?;
        self.circle_repository
            .create(&circle)
            .map(|_| CreateCircleOutput {
                circle_id: usize::from(circle.id),
                owner_id: usize::from(owner_id),
            })
    }
}
```

ã²ã¨ã¤ã²ã¨ã¤è¦‹ã¦ã„ãã¾ã™ã€‚

1. usecase ã® io (å…¥å‡ºåŠ›)
   usecase ã® io ã‚’ã€`CreateCircleInput` ã¨ `CreateCircleOutput` ã¨ã—ã¦å®šç¾©ã—ã¾ã™ã€‚
2. CreateCircleUsecase æ§‹é€ ä½“
   `CreateCircleUsecase` ã¯ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹æ§‹é€ ä½“ã§ã™ã€‚ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ã¯ã€`CircleRepositoryInterface` ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã—ãŸã‚‚ã®ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚

3. impl CreateCircleUsecase
   `CreateCircleUsecase` ã®æ§‹é€ ä½“ã«å¯¾ã—ã¦ã€ï¼’ã¤ãƒ¡ã‚½ãƒƒãƒ‰ã€`new` ã¨ `execute` ã‚’å®Ÿè£…ã—ã¾ã™ã€‚

   - new ãƒ¡ã‚½ãƒƒãƒ‰
     ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆã™ã‚‹ãŸã‚ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚`CircleRepositoryInterface` ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã—ãŸã‚‚ã®ã‚’å—ã‘å–ã‚Šã¾ã™ã€‚
     ä»–ã®è¨€èªã§è¨€ã†ã¨ã“ã‚ã®ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ¼ã§ã™ã€‚ã“ã“ã«ã€ä¾å­˜ã‚’æ³¨å…¥ã—ã¾ã™ã€‚å®Ÿæ…‹ã§ã¯ãªãã€æŠ½è±¡(ãƒˆãƒ¬ã‚¤ãƒˆ)ã‚’è¨­å®šã™ã‚‹ã“ã¨ã§ã€ä¾å­˜æ€§é€†è»¢ã®åŸå‰‡ã‚’å®Ÿç¾ã—ã¾ã™ã€‚

   - execute ãƒ¡ã‚½ãƒƒãƒ‰
     ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ã‚’å®Ÿè¡Œã™ã‚‹ãŸã‚ã®ãƒ¡ã‚½ãƒƒãƒ‰ã§ã™ã€‚`CreateCircleInput` ã‚’å—ã‘å–ã‚Šã€`Circle Entity` ã‚’ä½œæˆã—ã€ãƒ¬ãƒã‚¸ãƒˆãƒªãƒ¼ã«ä¿å­˜ã—ã¾ã™ã€‚
     `self` ã¨ã¯ã€`CreateCircleUsecase` ã®è‡ªèº«ã‚’æŒ‡ã—ã¾ã™ã€‚ä»Šå›ã¯ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒï¼‘ã¤ã—ã‹ãªã„ã®ã§ã€`self.circle_repository` ã§ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«ã‚¢ã‚¯ã‚»ã‚¹ã§ãã€ãã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒã€`CircleRepositoryInterface` ãƒˆãƒ¬ã‚¤ãƒˆã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ã“ã¨ãŒä¿è¨¼ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€`create` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã™ã“ã¨ãŒã§ãã¾ã™ã€‚

ã“ã‚Œã§ã€ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ã¯ãƒ‰ãƒ¡ã‚¤ãƒ³ã®ã¿ã«ä¾å­˜ã—ã€ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ä¾å­˜ã—ãªã„ã‚ˆã†ã«å®Ÿè£…ã§ãã¾ã—ãŸã€‚

### ãƒ—ãƒ¬ã‚¼ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¬ã‚¤ãƒ¤ãƒ¼

ãƒ—ãƒ¬ã‚¼ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³ãƒ¬ã‚¤ãƒ¤ãƒ¼ã§ã¯ã€ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®å®šç¾©ã€ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®å—ã‘å–ã‚Šã€ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³å±¤ã«æ¸¡ã™å€¤ã®ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’è¡Œã„ã¾ã™ã€‚

```Rust
#[derive(Debug, serde::Deserialize, serde::Serialize)]
pub struct CreateCircleRequestBody {
    pub circle_name: String,
    pub capacity: usize,
    pub owner_name: String,
    pub owner_age: usize,
    pub owner_grade: usize,
    pub owner_major: String,
}

impl std::convert::From<CreateCircleRequestBody> for CreateCircleInput {
    fn from(
        CreateCircleRequestBody {
            circle_name,
            capacity,
            owner_name,
            owner_age,
            owner_grade,
            owner_major,
        }: CreateCircleRequestBody,
    ) -> Self {
        CreateCircleInput::new(
            circle_name,
            capacity,
            owner_name,
            owner_age,
            owner_grade,
            owner_major,
        )
    }
}

#[derive(Debug, serde::Deserialize, serde::Serialize)]
pub struct CreateCircleResponseBody {
    pub circle_id: usize,
    pub owner_id: usize,
}

impl std::convert::From<CreateCircleOutput> for CreateCircleResponseBody {
    fn from(
        CreateCircleOutput {
            circle_id,
            owner_id,
        }: CreateCircleOutput,
    ) -> Self {
        CreateCircleResponseBody {
            circle_id,
            owner_id,
        }
    }
}

pub async fn handle_create_circle(
    State(state): State<AppState>,
    Json(body): Json<CreateCircleRequestBody>,
) -> Result<Json<CreateCircleResponseBody>, String> {
    let circle_circle_input = CreateCircleInput::from(body);
    let mut usecase = CreateCircleUsecase::new(state.circle_repository);
    usecase
        .execute(circle_circle_input)
        .map(CreateCircleResponseBody::from)
        .map(Json)
        .map_err(|e| e.to_string())
}

#[derive(Clone)]
struct AppState {
    circle_repository: CircleRepository,
}

fn router() -> Router<AppState> {
    Router::new()
        .route("/circle", post(handle_create_circle))
}

#[tokio::main]
async fn main() -> Result<(), ()> {
    let state = AppState {
        circle_repository: CircleRepository::new(),
    };

    let app = router().with_state(state);

    let listener = tokio::net::TcpListener::bind("127.0.0.1:3000")
        .await
        .unwrap();
    println!("Listening on: {}", listener.local_addr().unwrap());
    axum::serve(listener, app).await.unwrap();
    Ok(())
}
```

ã²ã¨ã¤ã²ã¨ã¤è¦‹ã¦ã„ãã¾ã™ã€‚

1. io (å…¥å‡ºåŠ›)
   `CreateCircleRequestBody` ã¯ã€ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®ãƒœãƒ‡ã‚£ã‚’å—ã‘å–ã‚‹ãŸã‚ã®æ§‹é€ ä½“ã§ã™ã€‚
   `CreateCircleRequestBody` ã« `from` ã‚’å®Ÿè£…ã—ã¦ã€`CreateCircleInput` ã‚’æ§‹ç¯‰ã§ãã‚‹ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚

   ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚‚åŒã˜ã‚ˆã†ãªå½¢ã§å®Ÿè£…ã—ã¦ã„ã¾ã™ã€‚

2. AppState
   `AppState` ã¯ã€ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã®çŠ¶æ…‹ã‚’è¡¨ã™æ§‹é€ ä½“ã§ã™ã€‚
   ã“ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã§ã¯ã€ãƒ¬ãƒã‚¸ãƒˆãƒªãƒ¼ã‚’ä¿æŒã—ã¦ã„ã¦ã€ä¾å­˜é–¢ä¿‚ã‚’è§£æ±ºã™ã‚‹ DI ã‚³ãƒ³ãƒ†ãƒŠã®ã‚ˆã†ãªå½¹å‰²ã‚’ã—ã¦ã„ã¾ã™ã€‚
   ä»Šå›ã¯ä¾å­˜ãŒä¸€ã¤ã—ã‹ãªã„ã®ã§ã€ã‚ã‚ŠãŒãŸã¿ã‚’æ„Ÿã˜ã‚‰ã‚Œã¾ã›ã‚“ãŒã€ä¾‹ãˆã°ã€ãƒ†ã‚¹ãƒˆæ™‚ã«ã€`CircleRepository` ã‚’`CircleRepositoryMock` ã®ã‚ˆã†ãªãƒ¢ãƒƒã‚¯ã«å·®ã—æ›¿ãˆã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
3. handle_create_circle
   `handle_create_circle` é–¢æ•°ã¯ã€ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’å—ã‘å–ã‚Šã€`CreateCircleUsecase` ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚
   ç¬¬ä¸€å¼•æ•°ã® `State(state)` ã§ã¯ `AppState` ã®å€¤ã‚’å–ã‚Šå‡ºã›ã¾ã™ã€‚
   å–ã‚Šå‡ºã—ãŸã€å€¤ã‚’ã€`CreateCircleUsecase` ã«æ³¨å…¥ã—ã¦ã€`execute` ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã³å‡ºã—ã¾ã™ã€‚å‰è¿°ã—ãŸ`usecase` ã‚’å®Ÿè¡Œã—ã¦ã„ã‚‹éƒ¨åˆ†ã§ã™ã€‚io ã¯ãã‚Œãã‚Œä»»æ„ã®å½¢å¼ã«å¤‰æ›ã—ã¦ã„ã¾ã™ã€‚

## ã¾ã¨ã‚

Rust axum DDD ã‚’ä½¿ã£ã¦ã€API ã‚µãƒ¼ãƒãƒ¼ã‚’å®Ÿè£…ã—ã¦ã¿ã¾ã—ãŸã€‚Rust ã¯ã¾ã ã¾ã ã€æ¥­å‹™ã§ã®æ¡ç”¨ãŒå°‘ãªã„ã§ã™ãŒã€ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã‚’ã¯ã˜ã‚ã«ç››ã‚Šä¸ŠãŒã£ã¦ãã‚‹ã¨æ€ã†ã®ã§ã€ãœã²ã€ä½¿ã£ã¦ã¿ã¦ãã ã•ã„ã€‚ã¾ãŸã€æ–°ã—ã„ã€ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ã‚„ã€é›†ç´„ã‚’è¿½åŠ ã—ã¦ã„ãŸã ã„ãŸã‚Šã—ã¦ã€å­¦ç¿’ã®æ‰‹åŠ©ã‘ã«ãªã‚Œã°ã¨æ€ã„ã¾ã™ã€‚
ä»Šå›ã®ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã¯ã€[ã“ã¡ã‚‰](https://github.com/katayama8000/axum-ddd-rust) ã«ã‚ã‚Šã¾ã™ã€‚
