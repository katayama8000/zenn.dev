---
title: 'api-server ã‚’ Rust ã¨ DDD ã§å®Ÿè£…ã™ã‚‹'
emoji: 'ğŸ¦'
type: 'tech' # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: [rust, axum, ddd, api]
published: false
---

## TL;DR

rust ã¨ ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ axum ã‚’ä½¿ã£ã¦ã€api-server ã‚’å®Ÿè£…ã—ã¦ã¿ã¾ã—ãŸã€‚

### å¯¾è±¡èª­è€…

- rust ã§ api-server ã‚’å®Ÿè£…ã—ãŸã„äºº
- DDD ã«èˆˆå‘³ãŒã‚ã‚‹äºº

### èª¬æ˜ã—ãªã„ã“ã¨

- rust ã®åŸºæœ¬çš„ãªæ–‡æ³•
- DDD ã®åŸºæœ¬çš„ãªè€ƒãˆæ–¹

## ã„ã–ã€å®Ÿè£…

### ä»•æ§˜ã‚’æ±ºã‚ã‚‹

ä»Šå›ã¯ã€å¤§å­¦ãŒã€ã‚µãƒ¼ã‚¯ãƒ«ã‚’ç®¡ç†ã™ã‚‹ã‚·ã‚¹ãƒ†ãƒ ã‚’ä½œã‚‹ã“ã¨ã«ã—ã¾ã—ãŸã€‚

- ãƒ¡ãƒ³ãƒãƒ¼ã‚’è¿½åŠ ã§ãã‚‹
- ãƒ¡ãƒ³ãƒãƒ¼ã‚’å‰Šé™¤ã§ãã‚‹
- 4 å¹´ç”Ÿã¯ã€è¿½åŠ ã§ããªã„
- 4 å¹´ç”Ÿã¯ã€å’æ¥­ã™ã‚‹
- ã‚µãƒ¼ã‚¯ãƒ«ã¯æœ€ä½ 3 äººä»¥ä¸Šã§ãªã„ã¨ã€æ´»å‹•ã§ããªã„
- ã‚µãƒ¼ã‚¯ãƒ«ã¯ã€æœ€å¤§äººæ•°ãŒæ±ºã¾ã£ã¦ã„ã‚‹
- ã‚µãƒ¼ã‚¯ãƒ«ã«ã¯ã€ä»£è¡¨è€…ãŒã„ã‚‹
- 20 æ­³ä»¥ä¸Šã®äººã¯ã€é£²ã¿ä¼šã«å‚åŠ ã§ãã‚‹
- 3 å¹´ç”Ÿã®ã¿ã€ä»£è¡¨è€…ã«ãªã‚Œã‚‹

### ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ¬ã‚¤ãƒ¤ãƒ¼

#### ã‚µãƒ¼ã‚¯ãƒ«é›†ç´„

ã¾ãšã¯ã€ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‹ã‚‰ä½œæˆã—ã¾ã™ã€‚
ã‚µãƒ¼ã‚¯ãƒ«é›†ç´„ã¯ã€é›†ç´„ãƒ«ãƒ¼ãƒˆã«ãªã‚‹ `Circle` ã¨ã€é›†ç´„å†…ã®ãƒ¡ãƒ³ãƒãƒ¼ã‚’è¡¨ã™ `Member` ã® 2 ã¤ã®ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‹ã‚‰æ§‹æˆã•ã‚Œã¾ã™ã€‚

```rust
pub struct Circle {
    pub id: CircleId, // ã‚µãƒ¼ã‚¯ãƒ«ã®ID (Value Object)
    pub name: String,
    pub capacity: usize,
    pub owner: Member,
    pub members: Vec<Member>,
}
```

```rust
pub struct Member {
    pub id: MemberId, // ãƒ¡ãƒ³ãƒãƒ¼ã®ID (Value Object)
    pub name: String,
    pub age: usize,
    pub grade: Grade,
    pub major: Major,
}
```

æ¬¡ã«ã€é›†ç´„ã«çŸ¥è­˜ã‚’ã‚ãŸãˆã‚‹ãŸã‚ã«ã€ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¾ã™ã€‚
rust ã§ã¯ `impl` ã§ `struct` ã«ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å®Ÿè£…ã—ã¾ã™ã€‚
â€» ç°¡å˜ã®ãŸã‚ã€ã‚¨ãƒ©ãƒ¼ã¯ `String` ã§è¿”ã—ã¦ã„ã¾ã™ãŒã€æœ¬æ¥ã¯ç‹¬è‡ªã®ã‚¨ãƒ©ãƒ¼å‹ã‚’ä½œæˆã—ãŸã»ã†ãŒè‰¯ã„ã§ã™ã€‚

```rust
impl Circle {
    // ã‚µãƒ¼ã‚¯ãƒ«ã®æ–°è¦ä½œæˆãƒ¡ã‚½ãƒƒãƒ‰
    pub fn new(id: CircleId, name: String, owner: Member, capacity: usize) -> Result<Self, String> {
        // ã‚ªãƒ¼ãƒŠãƒ¼ã¯3å¹´ç”Ÿã®ã¿ãªã‚Œã‚‹
        if owner.grade != Grade::Third {
            return Err("Owner must be 3rd grade".to_string());
        }

        Ok(Circle {
            id,
            name,
            owner,
            capacity,
            members: vec![],
        })
    }

    // ã‚µãƒ¼ã‚¯ãƒ«ã®å†æ§‹æˆãƒ¡ã‚½ãƒƒãƒ‰
    pub fn reconstruct(
        id: CircleId,
        name: String,
        owner: Member,
        capacity: usize,
        members: Vec<Member>,
    ) -> Self {
        Circle {
            id,
            name,
            owner,
            capacity,
            members,
        }
    }

    // ã‚µãƒ¼ã‚¯ãƒ«ãŒæº€å“¡ã‹ã©ã†ã‹ã‚’åˆ¤å®šã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰
    pub fn is_full(&self) -> bool {
        self.members.len() + 1 >= self.capacity
    }

    // ã‚µãƒ¼ã‚¯ãƒ«ãŒé‹å–¶å¯èƒ½ã‹ã©ã†ã‹ã‚’åˆ¤å®šã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰
    pub fn is_runnable(&self) -> bool {
        self.members.len() + 1 >= 3
    }

    // é£²ã¿ä¼šã«å‚åŠ ã§ãã‚‹ã‹ã©ã†ã‹ã‚’åˆ¤å®šã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰
    pub fn is_drinkable_alcohol(member: &Member) -> bool {
        member.is_adult()
    }

    // ãƒ¡ãƒ³ãƒãƒ¼ã‚’ã‚µãƒ¼ã‚¯ãƒ«ã«è¿½åŠ ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰
    pub fn add_member(&mut self, member: Member) -> Result<(), String> {
        // æº€å“¡ã®å ´åˆã¯ã‚µãƒ¼ã‚¯ãƒ«ã«å…¥ã‚Œãªã„
        if self.is_full() {
            return Err("Circle member is full".to_string());
        }

        // 4å¹´ç”Ÿã¯ã‚µãƒ¼ã‚¯ãƒ«ã«å…¥ã‚Œãªã„
        if member.grade == Grade::Fourth {
            return Err("4th grade can't join circle".to_string());
        }

        self.members.push(member);
        Ok(())
    }

    // ãƒ¡ãƒ³ãƒãƒ¼ã‚’ã‚µãƒ¼ã‚¯ãƒ«ã‹ã‚‰å‰Šé™¤ã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰
    pub fn remove_member(&mut self, member: &Member) -> Result<(), String> {
        // ã‚ªãƒ¼ãƒŠãƒ¼ã¯å‰Šé™¤ã§ããªã„
        if self.owner.id == member.id {
            return Err("Owner can't be removed".to_string());
        }
        self.members.retain(|m| m.id != member.id);
        Ok(())
    }

    // 4å¹´ç”Ÿã‚’å’æ¥­ã•ã›ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰
    pub fn graduate(&mut self) {
        self.members.retain(|m| m.grade != Grade::Fourth);
    }
}
```

```rust
impl Member {
    // ãƒ¡ãƒ³ãƒãƒ¼ã®æ–°è¦ä½œæˆãƒ¡ã‚½ãƒƒãƒ‰
    pub fn new(id: MemberId, name: String, age: usize, grade: Grade, major: Major) -> Self {
        Member {
            id,
            name,
            age,
            grade,
            major,
        }
    }

    // 20æ­³ä»¥ä¸Šã‹ã©ã†ã‹ã‚’åˆ¤å®šã™ã‚‹ãƒ¡ã‚½ãƒƒãƒ‰
    pub fn is_adult(&self) -> bool {
        self.age >= 20
    }
}
```

#### ãƒãƒ¼ãƒˆ

ãƒ‰ãƒ¡ã‚¤ãƒ³ã®æŒ¯ã‚‹èˆã„ã‚’å¤–éƒ¨ã«å…¬é–‹ã™ã‚‹ãŸã‚ã®ãƒãƒ¼ãƒˆã‚’ä½œæˆã—ã¾ã™ã€‚
ã‚µãƒ¼ã‚¯ãƒ«é›†ç´„ã‚’æ“ä½œã™ã‚‹ãŸã‚ã®ãƒãƒ¼ãƒˆã‚’ä½œæˆã—ã¾ã™ã€‚

```rust
pub trait CircleRepositoryTrait {
    fn find_circle_by_id(&self, circle_id: &CircleId) -> Result<Circle, Error>;
    fn create(&mut self, circle: &Circle) -> Result<(), Error>;
    fn save(&mut self, circle: &Circle) -> Result<(), Error>;
    fn delete(&mut self, circle: &Circle) -> Result<(), Error>;
}
```

ãƒˆãƒ¬ã‚¤ãƒˆã¯ã€ä»–ã®è¨€èªã§è¨€ã†ã¨ã“ã‚ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã®ã‚ˆã†ãªã‚‚ã®ã§ã™ã€‚

### ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£ãƒ¬ã‚¤ãƒ¤ãƒ¼

ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ã€æ°¸ç¶šåŒ–ã‚’æ‹…ã„ã¾ã™ã€‚
æ°¸ç¶šåŒ–å…ˆã¯å•ã„ã¾ã›ã‚“ã€‚Firestore ã‚„ Postgres ãªã©ã€ãªã‚“ã§ã‚‚è‰¯ã„ã§ã™ã€‚
ä»Šå›ã¯ã€ãƒ¡ãƒ¢ãƒªã«ä¿å­˜ã™ã‚‹ã“ã¨ã«ã—ã¾ã—ãŸã€‚

ã‚¤ãƒ³ãƒ•ãƒ©ã‚¹ãƒˆãƒ©ã‚¯ãƒãƒ£ãƒ¬ã‚¤ãƒ¤ãƒ¼ã§ã¯ã€ãƒ‰ãƒ¡ã‚¤ãƒ³ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒãƒ¼ãƒˆã‚’å®Ÿè£…ã—ã¾ã™ã€‚

```rust
use anyhow::Error;

use crate::domain::{
    aggregate::{circle::Circle, value_object::circle_id::CircleId},
    repository::circle_repository_trait::CircleRepositoryTrait,
};

use super::db::Db;

pub struct CircleRepository {
    db: Db,
}

impl CircleRepository {
    pub fn new() -> Self {
        Self { db: Db::new() }
    }
}

impl CircleRepositoryTrait for CircleRepository {
    fn find_circle_by_id(&self, circle_id: &CircleId) -> Result<Circle, Error> {
        match self.db.find(&circle_id.to_string()) {
            Some(circle) => Ok(circle.clone()), // Clone the Circle to return it
            None => Err(Error::msg("Circle not found")),
        }
    }

    fn create(&mut self, circle: &Circle) -> Result<(), Error> {
        match self.db.create(circle.clone()) {
            Some(_) => Ok(()),
            None => Err(Error::msg("Circle already exists")),
        }
    }

    fn save(&mut self, circle: &Circle) -> Result<(), Error> {
        match self.db.update(circle.clone()) {
            Some(_) => Ok(()),
            None => Err(Error::msg("Circle not found")),
        }
    }

    fn delete(&mut self, circle: &Circle) -> Result<(), Error> {
        match self.db.delete(&circle.id.to_string()) {
            Some(_) => Ok(()),
            None => Err(Error::msg("Circle not found")),
        }
    }
}
```

DB ã®å®Ÿè£…ã¯ DDD ã«ãã‚Œã»ã©é–¢ä¿‚ãªã„ã®ã§ã€ç›®ã‚’é€šã™ç¨‹åº¦ã§å¤§ä¸ˆå¤«ã§ã™ã€‚
::::details ãƒ¡ãƒ¢ãƒªä¸Šã«ä¿å­˜ã™ã‚‹ DB ã®å®Ÿè£…

```rust
use crate::domain::aggregate::circle::Circle;
use std::collections::HashMap;

#[derive(Clone)]
pub struct Db {
    db: HashMap<String, Circle>,
}

impl Db {
    pub fn new() -> Self {
        Self { db: HashMap::new() }
    }

    pub fn update(&mut self, circle: Circle) -> Option<Circle> {
        if self.is_registered(&circle.id.to_string()) {
            self.db.insert(circle.id.to_string(), circle)
        } else {
            None
        }
    }

    pub fn create(&mut self, circle: Circle) -> Option<Circle> {
        if self.is_registered(&circle.id.to_string()) {
            Some(circle)
        } else {
            self.db.insert(circle.id.to_string(), circle)
        }
    }

    pub fn find(&self, circle_id: &str) -> Option<&Circle> {
        self.db.get(circle_id)
    }

    pub fn delete(&mut self, circle_id: &str) -> Option<Circle> {
        self.db.remove(circle_id)
    }

    fn is_registered(&self, circle_id: &str) -> bool {
        self.db.contains_key(circle_id)
    }
}

```

::::

### ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ãƒ¬ã‚¤ãƒ¤ãƒ¼
